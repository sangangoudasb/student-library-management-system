package com.example.student.library.management.system.model;


import com.example.student.library.management.system.enums.CardStatus;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;
import java.util.List;

@Entity
@Table(name="card")
public class Card {

    @Id
    @Column(name="id")
    @GeneratedValue(strategy= GenerationType.IDENTITY)   // this annotation is used when we want to create an
    private int id;                                // autogenerated pk where it will create pk for each table one by one.

    @Column(name="card_status", nullable = false)
    @Enumerated(value=EnumType.STRING)// this annotation is used whatever the values given in enum class those will be
    private CardStatus cardStatus;    // collected and converted to string and stored in database.

    @Column(name="expiry_date", nullable = false)
    private String expiryDate;

    @Column(name="created_date", nullable = false)
    @CreationTimestamp // when a new card is added it will automatically add date and time using system current datetime.
    private Date createdDate; // whenever we use creationtimestamp annotation the data type should be Date.

    @Column(name="updated_date", nullable = false)
    @UpdateTimestamp // when a card is updated it will automatically add date and time.
    private Date updatedDate; //whenever we use UpdatedTimestamp annotation the data type should be Date.
                             // or whenever the date and time is taken from system then data type should be Date.

    @JsonBackReference
    // this annotation says the reference is already given in previous class i.e Card. So no need to print again. This is given at @JoinColumn annotation.
    @JoinColumn         //this annotation it joins pk student_id from student table as a foreign key in card table
    @OneToOne            // bcz the relationship bw card and student table is one to one. we can also give fk as cardid in student table. but 1st one makes easy.
    private Student student;

    @JsonManagedReference
    @OneToMany(mappedBy="card")
    private List<Book> booksOfCard;

    @JsonManagedReference
    @OneToMany(mappedBy="card")
    private List<Transcation> transcationList;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public CardStatus getCardStatus() {
        return cardStatus;
    }

    public void setCardStatus(CardStatus cardStatus) {
        this.cardStatus = cardStatus;
    }

    public String getExpiryDate() {
        return expiryDate;
    }

    public void setExpiryDate(String expiryDate) {
        this.expiryDate = expiryDate;
    }

    public Date getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }

    public Date getUpdatedDate() {
        return updatedDate;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public List<Book> getBooksOfCard() {
        return booksOfCard;
    }

    public void setBooksOfCard(List<Book> booksOfCard) {
        this.booksOfCard = booksOfCard;
    }

    public List<Transcation> getTranscationList() {
        return transcationList;
    }

    public void setTranscationList(List<Transcation> transcationList) {
        this.transcationList = transcationList;
    }

    public void setUpdatedDate(Date updatedDate) {
        this.updatedDate = updatedDate;

    }
}
